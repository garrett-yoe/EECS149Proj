target C {
  platform: {
    name: "rp2040",
    board: "pololu_3pi_2040_robot"
  },
  single_threaded: true
}

import Display from "lib/Display.lf"
import Motors from "lib/Motors.lf"

preamble {=
  #include <stdio.h>
  #include <pico/stdlib.h>
  #include <hardware/gpio.h>
  #include <hardware/uart.h>
  #include <string.h>

  #define UART_ID uart0
  #define BAUD_RATE 115200
  #define UART_TX_PIN 28
  #define UART_RX_PIN 29
=}

reactor UARTrec {
  input rec: bool
  output mess: string

  reaction(startup) -> mess{=
    lf_set(mess, "WAITING");
  =}

  initial mode RECEIVING  {
    reaction(rec) -> mess {=
      static char uart_buf[17];
      static int index = 0;
      if(rec->value) {
        while(uart_is_readable(UART_ID)) {
          char let = uart_getc(UART_ID);
          if (let == '\r' || let == '\n') {
            break;
          }
          uart_buf[index] = let;
          index++;
        }
        uart_buf[index] = '\0';
        index = 0;
      }
      lf_set(mess, uart_buf);
    =}
  }
}

reactor Robot {
  input com: string
  output notify: string

  motors = new Motors()

  reaction(startup) -> notify {=
    lf_set(notify, "START");
  =}

  initial mode STOPPED {
    reaction(com) -> reset(FORWARD), reset(RIGHT), reset(LEFT), notify, motors.left_power, motors.right_power {=
      if (strcmp(com->value, "for") == 0) {
        lf_set_mode(FORWARD);
        lf_set(notify, "STO FOR");
        lf_set(motors.left_power, 0.1f);
        lf_set(motors.right_power, 0.1f);
      } else if (strcmp(com->value, "rig") == 0) {
        lf_set_mode(RIGHT);
        lf_set(notify, "STO RIG");
        lf_set(motors.left_power, 0.0f);
        lf_set(motors.right_power, 0.1f);
      } else if (strcmp(com->value, "lef") == 0) {
        lf_set_mode(LEFT);
        lf_set(notify, "STO LEF");
        lf_set(motors.left_power, 0.1);
        lf_set(motors.right_power, 0.0f);
      } else {
        lf_set(notify, com->value);
        lf_set(motors.left_power, 0.0f);
        lf_set(motors.right_power, 0.0f); 
      }
    =}
  }

  mode FORWARD {
    reaction(com) -> reset(STOPPED), reset(RIGHT), reset(LEFT), notify, motors.left_power, motors.right_power {=
      if (strcmp(com->value, "sto") == 0) {
        lf_set_mode(STOPPED);
        lf_set(notify, "FOR STO");
        lf_set(motors.left_power, 0.0);
        lf_set(motors.right_power, 0.0f);
      } else if (strcmp(com->value, "rig") == 0) {
        lf_set_mode(RIGHT);
        lf_set(notify, "FOR RIG");
        lf_set(motors.left_power, 0.0f);
        lf_set(motors.right_power, 0.1f);
      } else if (strcmp(com->value, "lef") == 0) {
        lf_set_mode(LEFT);
        lf_set(notify, "FOR LEF");
        lf_set(motors.left_power, 0.1);
        lf_set(motors.right_power, 0.0f);
      } else {
        lf_set(notify, com->value);
        lf_set(motors.left_power, 0.1f);
        lf_set(motors.right_power, 0.1f); 
      }
    =}
  }

  mode RIGHT {
    reaction(com) -> reset(FORWARD), reset(STOPPED), reset(LEFT), notify, motors.left_power, motors.right_power {=
      if (strcmp(com->value, "for") == 0) {
        lf_set_mode(FORWARD);
        lf_set(notify, "RIG FOR");
        lf_set(motors.left_power, 0.1f);
        lf_set(motors.right_power, 0.1f);
      } else if (strcmp(com->value, "sto") == 0) {
        lf_set_mode(STOPPED);
        lf_set(notify, "RIG STO");
        lf_set(motors.left_power, 0.0);
        lf_set(motors.right_power, 0.0f);
      } else if (strcmp(com->value, "lef") == 0) {
        lf_set_mode(LEFT);
        lf_set(notify, "RIG LEF");
        lf_set(motors.left_power, 0.1);
        lf_set(motors.right_power, 0.0f);
      } else {
        lf_set(notify, com->value);
        lf_set(motors.left_power, 0.0f);
        lf_set(motors.right_power, 0.1f); 
      }
    =}
  }

  mode LEFT {
    reaction(com) -> reset(FORWARD), reset(RIGHT), reset(STOPPED), notify, motors.left_power, motors.right_power {=
      if (strcmp(com->value, "for") == 0) {
        lf_set_mode(FORWARD);
        lf_set(notify, "LEF FOR");
        lf_set(motors.left_power, 0.1f);
        lf_set(motors.right_power, 0.1f);
      } else if (strcmp(com->value, "rig") == 0) {
        lf_set_mode(RIGHT);
        lf_set(notify, "LEF RIG");
        lf_set(motors.left_power, 0.0f);
        lf_set(motors.right_power, 0.1f);
      } else if (strcmp(com->value, "sto") == 0) {
        lf_set_mode(STOPPED);
        lf_set(notify, "LEF STO");
        lf_set(motors.left_power, 0.0);
        lf_set(motors.right_power, 0.0f);
      } else {
        lf_set(notify, com->value);
        lf_set(motors.left_power, 0.1f);
        lf_set(motors.right_power, 0.0f); 
      }
    =}
  }

}

main reactor {
  timer t(0, 1000 ms)
  state received: bool = false
  
  uart = new UARTrec()
  d = new Display()
  rob = new Robot()

  rob.notify->d.line2
  uart.mess->rob.com

  reaction(startup) {=
      stdio_init_all();
      gpio_init(PICO_DEFAULT_LED_PIN);
      gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);
      //UART setup
      uart_init(UART_ID, BAUD_RATE);
      gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);
      gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);
  =}

  reaction(t) -> uart.rec, d.line0 {=
    static char buf0[17];
    if (uart_is_readable(UART_ID)) {
      snprintf(buf0, 17, "GOT MESS");
      lf_set(uart.rec, true);
    } else {
      snprintf(buf0, 17, "NO MESS");
    }
    lf_set(d.line0, buf0);
  =}
}